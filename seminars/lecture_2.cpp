// Передача данных между процессами

// БЛОКИРУЮЩИЕ ФУНКЦИИ

//режимы

// 1. базовый

int MPI_Send(
	void* buf,
	int count,
	MPI_Datatype type,
	int dest,
	int tag, // выбираем сами
	MPI_Comm comm
);

neibLeft = (myrank == 0) ? MPI_PROC_NULL : myrank - 1;
neibRight = (myrank == size - 1) ? MPI_PROC_NULL : myrank + 1;

// унифицированный механизм обмена сообщениями
send(neibLeft);
send(neibRight);

recv(neibLeft);
recv(neibRight);

// при MPI_Send процесс ничего не передаёт, он делегирует это действие дальше в систему, та буфферезирует сообщение в системный MPI_Buffer

// 1)  сообщение помещается в буффер - управление снова возвращается в процесс, однако сообщение её не епередано
// 2)  сообщение не помещается в буффер(слишком большое или буффер просто заполнен) -> MPI_Send блокирует дальнейшие действия, пока данные не передадутся. Однако гарантии, что сообщение передано, нет. Гарантируется лишь то, что данные будут записаны в буффер, а что они будт доставлены - нет.

//2. синхронизации

int MPI_Ssend( // блокирует процесс, пока не отзовётся принимающий процесс(он должен вызвать MPI_Recv)
	void* buf,
	int count,
	MPI_Datatype type,
	int dest,
	int tag,
	MPI_Comm comm
);
// Тоже нет гараний, что данные доставлены. Гарантия лишь в том, что принимающий процесс дошёл до определённой точки программы и вызвал метод MPI_Recv.


//3. режим с буфферезацией
int MPI_Bsend(
	void* buf,
	int count,
	MPI_Datatype type,
	int dest,
	int tag, // выбираем сами
	MPI_Comm comm
);

// Можно выдeлить в памяти буффер нужного размера и сказать MPI, чтобы использовала буффер, как системный.

// Нюансы создания буффера: необходимо определить размер буффера, желательно ф-ей:
int MPI_Pack_size(
	int count,
	MPI_Datatype type,
	MPI_Comm comm,
	int* size // указатель на размер необходимого пространства(?)
);

// Для хранния дополнительных параметров необходимо увеличить size:
size += MPI_BSEND_OVERHEAD;

sbuf = malloc(size); // выделяем память
MPI_Buffer_attach(void* sbuf, int size); // устанавливаем выделенную память как системный буффер

// после операций необходимо вернуть всё на места
MPI_Buffer_dettach // (?)

//4. режим виртуальной загруженности(?)

int MPI_Rsend( // гарантирует, что вызывается после того, как принимающий процесс вызвад MPI_Recv
	void* buf,
	int count,
	MPI_Datatype type,
	int dest,
	int tag,
	MPI_Comm comm
);
// Имеет меньше накладных расходов, но гарантиии делают его не универсальным. Используется редко.


// Ни один из описанных четырёх методов не гарантирует, что данные будут получены, однако есть гарантия, что данные могут быть переиспользованы.

// ----

// Приём данных с блокировкой

int MPI_Recv( 
	void* buf,
	int count, // можно указывать неточно, главное, чтобы было не меньше, чем отправили
	MPI_Datatype type,
	int source,
	int tag,
	MPI_Comm comm,
	MPI_Status* status
);

// Блокирующая ф-ия, блокирует до тех пор, пока данные не будут приняты и уложены в пользовательский буффер -> есть гарантия, что данные получены.
// В качестве source можно указывать не реальный номер процесса, а MPI_ANY_SOURCE. И для тэга: MPI_ANY_TAG. Следует использовать только по необходимости. Благодаря этим значениям можно убрать фиксированный порядок(пригодиться в первой лабе)



// Возможности MPI

MPI_Get_count(
	MPI_Status* status, 
	MPI_Datatype type, // для того, чтобы получить результат в единицах указанного типа
	int* count
);

// Для получения информации о сообщении до того, как мы его получим. Блокирует процесс, пока не получим сообщение в коммуникаторе. Как только сообщение там появилось, процесс разблакируется, однако само мообщуние не получено.
MPI_Probe( 
	int source, // не стоит указывать MPI_ANY_SOURCE, т.к. source в MPI_Probe и MPI_Recv может не совпадать
	int tag,
	MPI_Comm comm,
	MPI_Status* status
);

// Теперь можно спокойно выделять память под сообщение, вы представляете?!


// НЕ БЛОКИРУЮЩИЙ РЕЖИМ

// Позволяет совмещать вычисления, которые выполняет процесс, и обмен данными.

// Но не даёт гарантий, что пользовательский буффер можно безопасно переиспользовать -> может произойти порча данных.

//1. базовый

int MPI_Isend(
	void* buf,
	int count,
	MPI_Datatype type,
	int dest,
	int tag,
	MPI_Comm comm,
	MPI_Request* request // аргумент для получения информации про передачу(скытый системный объект(Ух ты!))
);

// Для трёх остальных типов аналогично с добавлением нужной буквы.

// Для получения информации о передаче есть несколько ф-ий.

int MPI_Wait(MPI_Request* request, MPI_Status* status); // блокирующая ф-ия ядл получения информации о передачи.

//Скрытые объекты удаляются каким-то образом с использованием этой штуки MPI_REQUEST_NULL и предыдущего запроса.
// Или 
int MPI_Request_free(MPI_Request* request);
//Освобождать надо обязательно.


// ТИПИЧНЫЕ ОШИБКИ, которе приводят к блокировке

// 1. ошибки с коммуникаторами, тэгами и т.п.
// 2. несоответствие порядка приёма и передачи
// 3. примерчик(о-хо-хо)

// 		proc 1			|	proc 2
		MPI_Send(1)		|	MPI_Send(0)
		MPI_Recv(1)		|	MPI_Recv(0)
// Если сообщение большое, то MPI_Send(1)	блокирует процесс, пока буффер не будет освобождён, 
// а освобождён он будет, если будет вызван MPI_Recv(0), но он не будет вызван, потому что сначала мы вызываем блокирующую ф-ию MPI_Send(0). 
//В таком сучае лучше использовать неблокирующую ф-ию.


// Решение(учитываем, что не можем записывать в буффер, пока не вызовем MPI_Wait(получаем подтверждение завершения передачи данных):
// 		proc 1			|	proc 2
		MPI_ISend(1)	|	MPI_ISend(0)
		MPI_Recv(1)		|	MPI_Recv(0)
		MPI_Wait()		|	MPI_Wait()

MPI_Test // неблокирующая ф-ия, которая возвращает, выполнена передача или нет(неблокирующий аналог wait).
