#pragma omp sections [options]

//Директивы и ф-ии синхронизации потоков

// 1. нежелательный
#pragma  omp barrier

// 2. последовательно выполнение
#pragma omp ordered

// 3. критическая секция, доступ к которой только у одного потока
#pragma omp critical [name]
// с помощью директивы выделяем критическую область (далее она в {})

// name - именновая кр.секция может встречаться в нескольких частях кода и везде она будет выполнятся только одним потоком

	// частный случай
	#pragma omp atomic 
	// используется для крит.секции из одного оператора

// 4. реализация кр.секции с помощью замков

// за пределами параллельной области объявляем замок
omp_lock_t lock;
void omp_init_lock(omp_lock_t *plock); // иициализация замка
void omp_set_lock(omp_lock_t *plock); // как мьютекс - захватываем замок на воде в секцию
void omp_unset_lock(omp_lock_t *plock); // выход из секции, разблокировка, все остальные ждут, пока замок не станет открытым
//разблокировать может только тот, кто заблокировал

// проверка блокировки замка:
int omp_test_lock(omp_lock_t *plock); //если он открыт, то мы его захватываем

// уничтожаем замок
void omp_destroy_lock(omp_lock_t *plock);

// Накладные расходы - организация нитей, в циклах - динамическое распределение нагрузки
// При нескольких нитях изменяется взаимодействие с кэшем.

// Пример для лабораторной

//Решение задачи Дирихле

/*
	 d^2(u)     d^2(u)
	-------- + ---------   = f(x_1, x_2)
	d(x_1^2)   d(x_2^2)  

	u(x_1, x_2)|	= μ(x_1, x_2)
			   |d(D)

	(x_1, x_2) принадлежит D = [0, l_1] x[0, l_2]

	Задача: найти приближённое значение ф-ии в узлах сетки.

	На лабораторной можно взять одинаковый шаг по i и j.

	Для аппроксимации проиводных:

	(y_(i_1 - 1)(i_2) - 2 * y_(i)(i_2) + y(i_1 + 1)(i_2))/ h^2 + (y_(i)(i_2 - 1) - 2 * y_(i)(i_2) + y(i_1)(i_2 + 1))/ h^2 

	МОжно использовать метод матричной прогонки.

	Но он имеет большую сложность, поэтому мы приводим подобные и переносим в одну сторону.

	y_(i_1)(i_2) = (y_(i_1 - 1)(i_2) +  y(i_1 + 1)(i_2) + y_(i)(i_2 - 1) + y(i_1)(i_2 + 1)) / 4 + h^2(f_(i_1)(i_2)) / 4

	Для рассчётной формулы добавляем итеративность( слева n+1, справа n).

	В пределах итерации вычисления можно выполнять абсолютно независимо.

	Имеем паралелльными как внешний, так и внутренний цикл.

-

/*
	для шестой лабы берём олновлённые значения, где можем:


	y_(i_1)(i_2) [N+1] = (y_(i_1 - 1)(i_2)[N+1] +  y(i_1 + 1)(i_2)[N] + y_(i)(i_2 - 1)[N+1] + y(i_1)(i_2 + 1)[N]) / 4 + h^2(f_(i_1)(i_2)) / 4

	Он уже пробленый, просто так не ||.
	Что делать в такой ситуации?

	Волна(на сетке узлов выглядит как линии \
											 \
											  \)



*/

/*
	Введение в математические методы распараллеливания
	...
	...
	...

*/